# 数据字典解决方案

## 不可配置字典表解决方案

1. [巧用枚举让字典表的管理和使用变得简单, 优雅](https://blog.csdn.net/u011511756/article/details/88094754)

好处

1. 可以有效防止魔法值问题, 防止出错, 便于修改.
2. 在代码中使用时, 和IDE的代码提示功能相结合, 可以非常方便的看到每个字典的属性情况, 便于选择, 使用方便.
3. 对于一些复杂的字典数据, 可以直接将函数添加在对应的枚举中, 非常优雅方便的进行使用.

## 可配置数据字典解决方案

## 分析

可配置数据字典使用可以分几个类型进行分析

1. 数据字典一般仅仅实现一部分数据可配置, 也就是说可以将数据字典分为`可配置数据字典`和`不可配置数据字典`.
2. 对于`可配置数据字典`来说, 一般会涉及到数据字典的增删改, 一个数据字典至少需要包含`value->label`, 增删肯定是要对`value->label`进行增删, 但是修改的话就可以分两种情况, (1)涉及到到底是仅仅修改`label`, 不需要修改`value`, (2)
`value`和`label`都需要仅仅修改.因为如果修改value的话, 那么还可能涉及到数据库原始数据的各种级联修改以及各种冲突等等会导致程序复杂性提升, 但如果仅仅修改label的话, 就没必要考虑各种数据库的级联变更问题, 而增加和删除字典表的相关项也没有必要去修改数据库. 
3. 代码中无可避免的会需要用到字典表中的数据, 例如系统中有一个功能, 判断如果用户在一个下拉框里面选了A选项, 那么后台需要执行一个功能, 而这个下拉框是可以配置的, 那么我们在代码里面就不能够使用`value->label`的值, 我们最好使用一个不可变的东西来代表A. 例如我们在代码里面使用一个name来代表A选项, 这样无论value和label怎么改变, 我们依然可是使用name来代表A.
4. 我们在使用数据字典的时候, 在后台如何使用, 以及在前台应该如何使用
    1. 一个数据表加一个字段来标记一个数据字典 : 这样的话可以很好的去使用数据字典, 但是实际上这样的话也会造成一些问题.
    2. 直接使用一个全局的数据字典类型来代表一个数据字典 : 这样的话实现比较简单, 但是
5. 我们该如何使用数据字典
    1. 在前台, 我们直接使用一个全局的数据字典类型来获取数据字典数据.
    2. 在后台, 我们使用什么来表示一个数据字典, 因为数据字典是可以配置的, 因此在使用数据字典的时候, 不能直接使用`value->label`.
6. 字典表删除再新增的时候应当注意, 例如一个字典项`{"value":"1", "label":"MP3"}`, 然后这个value在其他表中被引用, 之后, 物理删除了这个字典项, 这样的话就可能会导致相关的一些数据不正常, 假如没有及时处理, 后来又新增了一个字典项, `{"value":"1","label":"PC"}`, 那么这样就造成了原先的MP3数据和之后的PC使用了同一个value, 这样就出现了错误数据.

### 配置功能

1. 在

### 标记数据字典唯一性
    
1. 使用`table#field`来标记一个数据字典, 而不是一个全局的数据字典类型来标记一个数据字典.
2. 配置和使用设置为分开的系统功能, 配置针对表结构, 使用针对 `table->field-->数据字典项`.
    字典类型仅仅作为针对数据库的配置, 具体使用的时候使用`table->field`标记一个数据字典, 总之在使用的时候从数据库中查出来的数据不包含字典类型.
    `table->field` 可以非常直接的确定一个数据字典的唯一性, 但是如果使用字典类型的话则未必, 例如有两张表, 两张表都有一个state属性, 字典项什么的都一样, 于是我们在使用的时候不自觉就会出现两个属性使用了同一个枚举或者同一个type, 然后再之后需要改动的时候就造成各种可能出现的错误.
    
### 前后台数据字典的使用

既然是可配置的数据字典, 那么前后台里面最好不能够有任何字典项`value->label`信息, 而事实上我们在前后台会无可避免的会使用到数据字典信息. 那么我们该怎么使用呢?

我们在不考虑针对数据字典的某一个字典项进行额外处理的情况下使用还是比较容易的.

后台 : 应为label和value都是可以改变的, 那么我们在代码里面就不能够使用`value->label`的值, 我们最好使用一个不可变的东西来代表A. 例如我们可以在数据表的字典项里面添加一个name字段, 同一个字典项name是不变的,



1. 数据字典一般仅仅实现一部分数据可配置, 也就是说可以将数据字典分为`可配置数据字典`和`不可配置数据字典`.
2. 对于`可配置数据字典`来说, 一般会涉及到数据字典的增删改, 一个数据字典至少需要包含`value->label`, 增删肯定是要对`value->label`进行增删, 但是修改的话就可以分两种情况, (1)涉及到到底是仅仅修改`label`, 不需要修改`value`, (2)
`value`和`label`都需要仅仅修改.因为如果修改value的话, 那么还可能涉及到数据库原始数据的各种级联修改以及各种冲突等等会导致程序复杂性提升, 但如果仅仅修改label的话, 就没必要考虑各种数据库的级联变更问题, 而增加和删除字典表的相关项也没有必要去修改数据库. 
3. 代码中无可避免的会需要用到字典表中的数据, 例如系统中有一个功能, 判断如果用户在一个下拉框里面选了A选项, 那么后台需要执行一个功能, 而这个下拉框是可以配置的, 那么我们在代码里面就不能够使用`value->label`的值, 我们最好使用一个不可变的东西来代表A. 例如我们在代码里面使用一个name来代表A选项, 这样无论value和label怎么改变, 我们依然可是使用name来代表A.
4. 我们在使用数据字典的时候, 在后台如何使用, 以及在前台应该如何使用
    1. 一个数据表加一个字段来标记一个数据字典 : 这样的话可以很好的去使用数据字典, 但是实际上这样的话也会造成一些问题.
    2. 直接使用一个全局的数据字典类型来代表一个数据字典 : 这样的话实现比较简单, 但是
5. 我们该如何使用数据字典
    1. 在前台, 我们直接使用一个全局的数据字典类型来获取数据字典数据.
    2. 在后台, 我们使用什么来表示一个数据字典, 因为数据字典是可以配置的, 因此在使用数据字典的时候, 不能直接使用`value->label`.
6. 字典表删除再新增的时候应当注意, 例如一个字典项`{"value":"1", "label":"MP3"}`, 然后这个value在其他表中被引用, 之后, 物理删除了这个字典项, 这样的话就可能会导致相关的一些数据不正常, 假如没有及时处理, 后来又新增了一个字典项, `{"value":"1","label":"PC"}`, 那么这样就造成了原先的MP3数据和之后的PC使用了同一个value, 这样就出现了错误数据.




## 需求和问题

1. 字典表在数据库里面管理, 字典表可以由页面进行配置配置.
2. 字典表是需要可配置的, 因此代码里面不能够有任何字典项信息, 那么字典表和代码衔接问题需要解决.
3. 前后台接收发送数据字典的方式.

## 设计思路

1. 要想使用数据库管理字典表首先需要建立字典表, 建立两张表, 一张管理字典类型信息, 一张管理字典项信息, 字典类型表和字典表为一对多关系.
2. 字典表的使用需要和字段结合起来, 那么就需要字段表以便于配置字段和字典表的信息(如果不使用字段表的话, 那么只能在代码里面直接去使用字典的键去获取字典, 那么就不能够做到字典的配置, 只能够做到字典项配置. 这样的话字典类型势必会对代码造成侵入性, 不方便后续扩展和管理).
3. 数据字典结合做成可配置式, 需要用到字段表, 字典类型表, 字典项表, 字段表确立字段和字典类型的关系, 这样就可以实现前台页面增删改查管理配置数据字典.
4. 代码里面肯定会需要用到字典表数据, 而字典表是需要可配置的, 因此代码里面不能够有任何字典项信息, 在此通过枚举来管理数据字典, 这样还可以避免魔法值问题.
5. 代码里面使用枚举会有很多问题, 在此使用解决方案 -> [巧用枚举让字典表的管理和使用变得简单, 优雅](https://blog.csdn.net/u011511756/article/details/88094754)
6. 代码里面无可避免会使用数据字典, 数据字典页面配置改变后, 项目里面可能会受到影响, 在此字典项表里面加入字段来判断当前数据字典是否在被代码使用, 如果在使用配置时则弹出提示信息. 
7. 数据字典配置后, 代码里面的枚举也需要改变, 如果使用人工编写枚举的话, 很容易造成失误, 而且特别麻烦, 在此采用velocity模型实时一键生成枚举, 实现数据字典和代码的良好衔接.
8. 数据字典增删改次数少, 但查询次数巨大, 可以更改表引擎为MyISam和采用redis缓存来提高访问速度.
9. 数据字典项表加入中英文标签, 支持中英文切换.
10. 后台提供字典表获取统一接口, 前台提供字典表统一查询方法.

> 遗留问题
>
> 1. 字典表配置更新后, 已经打开的页面来不及更新枚举
>
>     没什么好的方法, 设计好一点, 尽量在很少人使用的时候修改, 实在不行, 修改后后台直接报错, 或前台页面提示或刷新. 甚至修改时直接抛出个维护中的页面.
>
> 2. 字典表配置更新后, 用到该枚举的表字段数据该如何解决.
>
>     手动更改数据库吧
>

## 优点

1. 数据字典可以由前台页面进行配置式管理.
2. 使用枚举在开发时非常方便. 实现和数据库字典的衔接.
3. 一键生成枚举实现开发时实时更新.
4. 加入中英文标签, 实现中英文切换.

## 详细

1. 页面初始化加载枚举
   1. 扫描当前页面是否有使用到枚举的地方, 有则提供枚举id, 到后台查询枚举id
   2. 若页面有页面枚举配置, 则到后台查询配置, 之后解析出枚举
   3. 后台接收之后到缓存中获取枚举
   4. 将枚举传到前台. 前台提供保存字典表方法.
2. 全局加载枚举
   1. 需要枚举时先在浏览器里面寻找, 需要配合config_id使用.

## 缓存

1. 以页面标识作为hKey做字典数据缓存.
2. 以字典类型作为hKey做字典表缓存.

sysDict : sysDictType-Object
sysDictLatestTime : datetime
sysDictSortType : list : 为了能够判断出到底是哪些字典数据更新了. -> 可以考虑通过数据库查询来获取更新的数据.

```text
    更新操作: 删除redis里面的缓存. 并设置更新时间
    
    1. 系统初始化时, 到redis里面获取缓存, 如果redis里面没有键, 则到数据库中查询数据并更新缓存, 在此期间加锁.
    
    一次请求使用时首先从redis中获取sysDictLatestTime判断字典是否已经更新.
    if(已经更新) {
        到sysDictSortType里面获取最早的更新时间
        if (最早的更新时间比当前环境的时间还晚){
            表示当前系统数据已经追不上redis更新速度, 则直接去数据库或从redis里面更新全部数据.
        } else {
            1. 通过分数获取最新的更新消息, 并从sysDict中查找相应的更新数据, 并更新环境.
            2. 更新环境的最新时间
        }
    }
    func 获取数据项()
    
    
    
    function 获取数据项(){
        使用本环境数据
        if (本环境没有字典数据){ // 这种情况一般用不到, 如果出现这种情况, 则log warning 日志记录.
            到redis里面找字典数据
            if (在redis中如果找不到字典数据) {
                加锁后, 到数据库中查询数据.
                更新redis, 更新更新时间, 更新sort, 去锁
            }
        }
    }
    
    function 获取更新的数据(){
        方案一 : 到数据库查询数据,
        方案二 : 使用sysDictS
    }
    
```
 
## 问题

1. 如果数据库删了字典表数据, 那么正在运行的环境怎么办, 环境中无可避免会用到相关字典表数据, 数据删掉系统岂不是直接垮了. 
    已经在代码中定义的数据仅仅使用put进行替换, 不进行删除.
    
    


## 数据字典表设计

1. 前后台交互, 前台传送字典参数时肯定传送字典类型和字典项, 总不能传送个guid吧, 这样guid就显得没什么用处了.
2. 字典项和字典类型两个应该唯一, 设计成一个联合主键, 使用联合主键查询更快更方便.
3. 在没有guid的情况下, 主键不能随便变动, 设置一个外键以防止这种情况, 并且防止脏数据.
4. 数据字典增删改次数少, 但查询次数巨大, 而且字典表只有管理员去进行更改, 可以更改表引擎为MyISam.

数据字典表 sql 如下

```sql
CREATE TABLE `sys_dict_type` (
    `name` varchar(50) NOT NULL COMMENT '字典名称, 唯一标识, sys_dict_item关联字段, 不能顺便更改',
    `label` varchar(200) NOT NULL COMMENT '显示名称',
    `tag` varchar(10) not null comment '字典类型',
    `ord` int(3) NOT NULL DEFAULT '50' COMMENT '顺序',
    `max_level` int(1) NOT NULL comment '最大级别',
    `comment` varchar(400) NOT NULL DEFAULT '' COMMENT '数据描述',
    `permission` char(3) not null default '' comment '规则{增删改}',
    `add_time` datetime NOT NULL default CURRENT_TIMESTAMP COMMENT '添加时间',
    `update_time` datetime NOT NULL default CURRENT_TIMESTAMP COMMENT '更新时间',
    `state` char(1) NOT NULL COMMENT 'y正常,n删除',
    PRIMARY KEY (`name`)
) DEFAULT CHARSET=utf8 COMMENT='系统字典表';

CREATE TABLE `sys_dict_item` (
    `type` varchar(50) NOT NULL COMMENT '字典类别',
    `name` varchar(50) not null comment '枚举的name, 作为字典项的识别标志, 在代码里面作为枚举标识使用, 无论字典如何配置, name不变, 一个枚举类型里面name唯一',
    `value` varchar(20) NOT NULL COMMENT '值',
    `cn_label` varchar(50) NOT NULL COMMENT '中文标签',
    `en_label` varchar(50) NOT NULL COMMENT '英文标签',
    `par_value` varchar(12) NOT NULL DEFAULT '' COMMENT '父ID, 多级字典表时有用',
    `level` int(1) NOT NULL DEFAULT '1' comment '层级, 当前字典项的层级, 多级字典表时有用',
    `ord` int(3) NOT NULL DEFAULT '10' COMMENT '顺序, 字典项显示的顺序',
    `comment` varchar(400) NOT NULL DEFAULT '' COMMENT '数据描述',
    `permission` char(2) not null default '' comment '权限规则{删, 改值}',
    `add_time` datetime NOT NULL default CURRENT_TIMESTAMP COMMENT '添加时间',
    `update_time` datetime NOT NULL default CURRENT_TIMESTAMP COMMENT '更新时间',
    `state` char(1) NOT NULL COMMENT 'y正常,n删除',
    PRIMARY KEY (`type`,`name`),
    constraint type
       FOREIGN KEY (`type`) REFERENCES `sys_dict_type` (`name`) ON DELETE RESTRICT ON UPDATE CASCADE
)  DEFAULT CHARSET=utf8 COMMENT='系统字典项表';
```

```sql
INSERT INTO `sys_dict_type` (`name`, `label`, `tag`, `max_level`, `comment`, permission, `state`)
VALUES
('sys_dict_type_package',  '字典类型包',  'sys',    '1',  '字典类型的包, 便于区分字典类型, 系统固有数据',  '111', 'y'),
('table_state',            '状态',       'com',    '1',  '数据表的状态字段, 判断数据状态类型',           '111', 'y'),
('control_type',           '控件类型',    'sys',   '1',  '控件类型, 生成前端代码或前端交互时使用',        '111', 'y');

INSERT INTO sys_dict_item (type, name, value, cn_label, en_label, permission, `state`)
VALUES
('sys_dict_type_package', 'business',       'bns',          '业务类',      'business',  '11', 'y'),
('sys_dict_type_package', 'common',         'com',          '通用类',      'common',    '11', 'y'),
('sys_dict_type_package', 'system',         'sys',          '系统类',      'system',    '11', 'y'),
('table_state',           'disable',        'n',            '禁用',        'disable',   '11', 'y'),
('table_state',           'enable',         'y',            '可用',        'enable',    '11', 'y'),
('control_type',          'text',           'text',         '文本输入框',   'text',    '11', 'y'),
('control_type',          'text_area',      'text_area',    '文本域',       'text_area',    '11', 'y'),
('control_type',          'number',         'number',       '数字输入框',   'number',    '11', 'y'),
('control_type',          'Radio',          'Radio',        '单选按钮组',   'Radio',    '11', 'y'),
('control_type',          'checkbox',       'checkbox',     '复选按钮组',   'checkbox',    '11', 'y'),
('control_type',          'select',         'select',       '下拉框',       'select',    '11', 'y'),
('control_type',          'multi_select',   'multi_select', '多选下拉框',   'multi_select',    '11', 'y'),
('control_type',          'show',           'show',         '普通显示框',   'show',    '11', 'y');

```
